/**
 * Enhanced Download Utilities for Smart ReadmeGen
 * Supports multiple formats and better file naming
 */

import { toast } from 'sonner';

// Convert markdown to HTML
const markdownToHtml = (markdown) => {
  // Simple markdown to HTML conversion
  return markdown
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^\* (.*$)/gim, '<li>$1</li>')
    .replace(/^\- (.*$)/gim, '<li>$1</li>')
    .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
    .replace(/\*(.*)\*/gim, '<em>$1</em>')
    .replace(/```([^`]+)```/gim, '<pre><code>$1</code></pre>')
    .replace(/`([^`]+)`/gim, '<code>$1</code>')
    .replace(/\n/gim, '<br>');
};

// Generate HTML template
const generateHtmlTemplate = (content, title) => {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3 { color: #2563eb; }
        code { 
            background: #f1f5f9; 
            padding: 2px 4px; 
            border-radius: 3px; 
            font-family: 'Monaco', 'Consolas', monospace;
        }
        pre { 
            background: #1e293b; 
            color: #e2e8f0; 
            padding: 16px; 
            border-radius: 8px; 
            overflow-x: auto;
        }
        blockquote {
            border-left: 4px solid #3b82f6;
            margin: 0;
            padding-left: 16px;
            color: #64748b;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }
        th, td {
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
            text-align: left;
        }
        th { background: #f8fafc; }
        .generated-by {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
            color: #64748b;
            font-size: 14px;
            text-align: center;
        }
    </style>
</head>
<body>
    ${markdownToHtml(content)}
    <div class="generated-by">
        <p>Generated by <strong>Smart ReadmeGen</strong> - AI-Powered README Generation</p>
    </div>
</body>
</html>`;
};

// Extract repo name from GitHub URL or use fallback
const extractRepoName = (githubUrl, fallback = 'README') => {
  if (!githubUrl) return fallback;
  
  try {
    const match = githubUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (match) {
      return `${match[1]}-${match[2]}`;
    }
  } catch (error) {
    console.warn('Failed to extract repo name:', error);
  }
  
  return fallback;
};

// Main download function with multiple format support
export const downloadReadme = async (content, options = {}) => {
  const {
    format = 'md',
    githubUrl = '',
    repoName = '',
    customFilename = ''
  } = options;

  try {
    let fileContent = content;
    let mimeType = 'text/markdown';
    let extension = 'md';
    
    // Determine filename
    const baseFilename = customFilename || 
                        repoName || 
                        extractRepoName(githubUrl) || 
                        'README';

    switch (format.toLowerCase()) {
      case 'md':
      case 'markdown':
        fileContent = content;
        mimeType = 'text/markdown';
        extension = 'md';
        break;
        
      case 'html':
        fileContent = generateHtmlTemplate(content, `${baseFilename} - README`);
        mimeType = 'text/html';
        extension = 'html';
        break;
        
      case 'txt':
      case 'text':
        // Strip markdown formatting for plain text
        fileContent = content
          .replace(/#{1,6}\s/g, '')
          .replace(/\*\*(.*?)\*\*/g, '$1')
          .replace(/\*(.*?)\*/g, '$1')
          .replace(/`(.*?)`/g, '$1')
          .replace(/```[\s\S]*?```/g, '[Code Block]')
          .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
        mimeType = 'text/plain';
        extension = 'txt';
        break;
        
      default:
        throw new Error(`Unsupported format: ${format}`);
    }

    // Create and download file
    const blob = new Blob([fileContent], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    
    a.href = url;
    a.download = `${baseFilename}-README.${extension}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    toast.success(`README downloaded as ${extension.toUpperCase()}!`, {
      description: `File: ${baseFilename}-README.${extension}`
    });

    return true;
  } catch (error) {
    console.error('Download error:', error);
    toast.error('Download failed', {
      description: error.message
    });
    return false;
  }
};

// Batch download multiple formats
export const downloadMultipleFormats = async (content, formats, options = {}) => {
  const results = [];
  
  for (const format of formats) {
    const result = await downloadReadme(content, { ...options, format });
    results.push({ format, success: result });
    
    // Small delay between downloads
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  const successful = results.filter(r => r.success).length;
  const total = results.length;
  
  if (successful === total) {
    toast.success(`All ${total} formats downloaded successfully!`);
  } else {
    toast.warning(`${successful}/${total} formats downloaded successfully`);
  }
  
  return results;
};

// Copy content to clipboard with format options
export const copyToClipboard = async (content, format = 'markdown') => {
  try {
    let textToCopy = content;
    
    if (format === 'html') {
      textToCopy = generateHtmlTemplate(content, 'README');
    } else if (format === 'plain') {
      textToCopy = content
        .replace(/#{1,6}\s/g, '')
        .replace(/\*\*(.*?)\*\*/g, '$1')
        .replace(/\*(.*?)\*/g, '$1')
        .replace(/`(.*?)`/g, '$1');
    }
    
    await navigator.clipboard.writeText(textToCopy);
    toast.success(`Content copied as ${format}!`);
    return true;
  } catch (error) {
    console.error('Copy error:', error);
    toast.error('Failed to copy content');
    return false;
  }
};

const downloadUtils = {
  downloadReadme,
  downloadMultipleFormats,
  copyToClipboard,
  extractRepoName
};

export default downloadUtils;
