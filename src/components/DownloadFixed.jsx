// FIXED DOWNLOAD FUNCTION - Uses correct S3 key format

const handleDownload = async (format = 'md') => {
  if (!result?.s3_location) {
    toast.error('No README available for download');
    return;
  }
  
  try {
    // FIXED: Extract repo info from GitHub URL
    const repoName = extractRepoName(githubUrl);
    const [owner, repo] = githubUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/)?.[1,2] || ['unknown', 'repo'];
    
    // FIXED: Use the correct S3 key format that matches your bucket structure
    const correctS3Key = `generated-readmes/${owner}/${repo}.md`;
    
    console.log('Using S3 key:', correctS3Key); // Debug log
    
    // OPTION 1: Try CloudFront first (faster if CORS works)
    let readmeContent;
    try {
      const cloudFrontUrl = `https://d3in1w40kamst9.cloudfront.net/${correctS3Key}`;
      console.log('Trying CloudFront URL:', cloudFrontUrl);
      
      const response = await fetch(cloudFrontUrl, {
        method: 'GET',
        headers: {
          'Accept': 'text/markdown,text/plain,*/*',
        },
      });
      
      if (response.ok) {
        readmeContent = await response.text();
      } else {
        throw new Error(`CloudFront failed: ${response.status}`);
      }
    } catch (cloudFrontError) {
      console.log('CloudFront failed, trying S3 direct:', cloudFrontError.message);
      
      // OPTION 2: Fallback to S3 direct access
      const s3DirectUrl = `https://smart-readme-lambda-31641.s3.amazonaws.com/${correctS3Key}`;
      console.log('Trying S3 direct URL:', s3DirectUrl);
      
      const s3Response = await fetch(s3DirectUrl, {
        method: 'GET',
        headers: {
          'Accept': 'text/markdown,text/plain,*/*',
        },
      });
      
      if (!s3Response.ok) {
        throw new Error(`S3 direct access failed: ${s3Response.status} - ${s3Response.statusText}`);
      }
      
      readmeContent = await s3Response.text();
    }
    
    if (!readmeContent) {
      throw new Error('No content received');
    }
    
    // Process different formats
    let fileContent = readmeContent;
    let mimeType = 'text/markdown';
    let extension = 'md';
    
    switch (format.toLowerCase()) {
      case 'html':
        fileContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${repoName} - README</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3 { color: #2563eb; }
        code { 
            background: #f1f5f9; 
            padding: 2px 4px; 
            border-radius: 3px; 
            font-family: 'Monaco', 'Consolas', monospace;
        }
        pre { 
            background: #1e293b; 
            color: #e2e8f0; 
            padding: 16px; 
            border-radius: 8px; 
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="content">
        ${readmeContent.replace(/\n/g, '<br>')}
    </div>
    <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #64748b; font-size: 14px; text-align: center;">
        <p>Generated by <strong>Smart ReadmeGen Enterprise</strong></p>
    </div>
</body>
</html>`;
        mimeType = 'text/html';
        extension = 'html';
        break;
        
      case 'txt':
        // Strip markdown formatting for plain text
        fileContent = readmeContent
          .replace(/#{1,6}\s/g, '')
          .replace(/\*\*(.*?)\*\*/g, '$1')
          .replace(/\*(.*?)\*/g, '$1')
          .replace(/`(.*?)`/g, '$1')
          .replace(/```[\s\S]*?```/g, '[Code Block]')
          .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
        mimeType = 'text/plain';
        extension = 'txt';
        break;
    }
    
    // Create and download file
    const blob = new Blob([fileContent], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    
    a.href = url;
    a.download = `${repoName}-README.${extension}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    toast.success(`README downloaded as ${extension.toUpperCase()}!`, {
      description: `File: ${repoName}-README.${extension}`
    });
    
  } catch (err) {
    console.error('Download error:', err);
    toast.error('Download failed', {
      description: err.message,
    });
  }
};

// Helper function to extract repo name
const extractRepoName = (url) => {
  if (!url) return 'README';
  try {
    const match = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    return match ? `${match[1]}-${match[2]}` : 'README';
  } catch {
    return 'README';
  }
};
